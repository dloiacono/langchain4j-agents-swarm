package com.github.dloiacono.ai.agents.rag;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.stream.Collectors;

/**
 * Simple RAG store implementation that uses basic text matching and keyword search
 * instead of complex embeddings. This provides functional RAG capabilities without
 * external dependencies.
 */
public class SimpleRAGStore {
    
    private static final String RAG_DIRECTORY = "./generated-project/.rag-store";
    private static final ConcurrentMap<String, List<DocumentSegment>> documentStore = new ConcurrentHashMap<>();
    
    /**
     * Document segment containing text content and metadata
     */
    public static class DocumentSegment {
        private final String content;
        private final String sourceFile;
        private final String generatedBy;
        private final String fileName;
        private final long indexedAt;
        private final Set<String> keywords;
        
        public DocumentSegment(String content, String sourceFile, String generatedBy, String fileName) {
            this.content = content;
            this.sourceFile = sourceFile;
            this.generatedBy = generatedBy;
            this.fileName = fileName;
            this.indexedAt = System.currentTimeMillis();
            this.keywords = extractKeywords(content);
        }
        
        private Set<String> extractKeywords(String text) {
            return Arrays.stream(text.toLowerCase()
                    .replaceAll("[^a-zA-Z0-9\\s]", " ")
                    .split("\\s+"))
                    .filter(word -> word.length() > 2)
                    .collect(Collectors.toSet());
        }
        
        public String getContent() { return content; }
        public String getSourceFile() { return sourceFile; }
        public String getGeneratedBy() { return generatedBy; }
        public String getFileName() { return fileName; }
        public long getIndexedAt() { return indexedAt; }
        public Set<String> getKeywords() { return keywords; }
        
        /**
         * Calculate relevance score based on keyword matching
         */
        public double calculateRelevance(Set<String> queryKeywords) {
            if (queryKeywords.isEmpty()) return 0.0;
            
            Set<String> intersection = new HashSet<>(keywords);
            intersection.retainAll(queryKeywords);
            
            return (double) intersection.size() / queryKeywords.size();
        }
    }
    
    /**
     * Search result containing segment and relevance score
     */
    public static class SearchResult {
        private final DocumentSegment segment;
        private final double relevanceScore;
        
        public SearchResult(DocumentSegment segment, double relevanceScore) {
            this.segment = segment;
            this.relevanceScore = relevanceScore;
        }
        
        public DocumentSegment getSegment() { return segment; }
        public double getRelevanceScore() { return relevanceScore; }
    }
    
    /**
     * Index a file into the RAG store
     */
    public static boolean indexFile(Path filePath, String agentId) {
        try {
            if (!Files.exists(filePath) || !Files.isRegularFile(filePath)) {
                return false;
            }
            
            String content = Files.readString(filePath);
            String fileName = filePath.getFileName().toString();
            
            // Split content into segments (simple approach - split by paragraphs or size)
            List<String> segments = splitContent(content);
            
            List<DocumentSegment> documentSegments = segments.stream()
                    .map(segment -> new DocumentSegment(segment, filePath.toString(), agentId, fileName))
                    .collect(Collectors.toList());
            
            // Store segments
            String storeKey = filePath.toString();
            documentStore.put(storeKey, documentSegments);
            
            System.out.println("Successfully indexed file: " + filePath + " (generated by: " + agentId + ")");
            return true;
            
        } catch (Exception e) {
            System.err.println("Failed to index file " + filePath + ": " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Search for relevant content based on query
     */
    public static List<SearchResult> search(String query, int maxResults) {
        Set<String> queryKeywords = Arrays.stream(query.toLowerCase()
                .replaceAll("[^a-zA-Z0-9\\s]", " ")
                .split("\\s+"))
                .filter(word -> word.length() > 2)
                .collect(Collectors.toSet());
        
        if (queryKeywords.isEmpty()) {
            return Collections.emptyList();
        }
        
        List<SearchResult> results = new ArrayList<>();
        
        // Search through all document segments
        for (List<DocumentSegment> segments : documentStore.values()) {
            for (DocumentSegment segment : segments) {
                double relevance = segment.calculateRelevance(queryKeywords);
                if (relevance > 0.0) {
                    results.add(new SearchResult(segment, relevance));
                }
            }
        }
        
        // Sort by relevance and limit results
        return results.stream()
                .sorted((a, b) -> Double.compare(b.getRelevanceScore(), a.getRelevanceScore()))
                .limit(maxResults)
                .collect(Collectors.toList());
    }
    
    /**
     * Get all indexed files
     */
    public static List<String> getIndexedFiles() {
        return documentStore.values().stream()
                .flatMap(List::stream)
                .map(DocumentSegment::getFileName)
                .distinct()
                .sorted()
                .collect(Collectors.toList());
    }
    
    /**
     * Index all files in the generated-project directory
     */
    public static void indexAllGeneratedFiles() {
        try {
            Path generatedDir = Paths.get("./generated-project");
            if (!Files.exists(generatedDir)) {
                System.out.println("Generated project directory does not exist yet: ./generated-project");
                return;
            }
            
            Files.walk(generatedDir)
                    .filter(Files::isRegularFile)
                    .filter(SimpleRAGStore::shouldIndexFile)
                    .forEach(path -> indexFile(path, "unknown"));
                    
        } catch (IOException e) {
            System.err.println("Failed to index generated files: " + e.getMessage());
        }
    }
    
    /**
     * Clear all indexed content
     */
    public static void clearStore() {
        documentStore.clear();
    }
    
    private static List<String> splitContent(String content) {
        List<String> segments = new ArrayList<>();
        
        // Split by double newlines (paragraphs) first
        String[] paragraphs = content.split("\n\n");
        
        for (String paragraph : paragraphs) {
            paragraph = paragraph.trim();
            if (paragraph.isEmpty()) continue;
            
            // If paragraph is too long, split it further
            if (paragraph.length() > 1000) {
                // Split by sentences or lines
                String[] lines = paragraph.split("\n");
                StringBuilder currentSegment = new StringBuilder();
                
                for (String line : lines) {
                    if (currentSegment.length() + line.length() > 1000 && currentSegment.length() > 0) {
                        segments.add(currentSegment.toString().trim());
                        currentSegment = new StringBuilder();
                    }
                    currentSegment.append(line).append("\n");
                }
                
                if (currentSegment.length() > 0) {
                    segments.add(currentSegment.toString().trim());
                }
            } else {
                segments.add(paragraph);
            }
        }
        
        return segments;
    }
    
    private static boolean shouldIndexFile(Path filePath) {
        String fileName = filePath.getFileName().toString();
        
        // Skip hidden files and directories
        if (fileName.startsWith(".")) {
            return false;
        }
        
        // Skip binary files and build artifacts
        String lowerFileName = fileName.toLowerCase();
        if (lowerFileName.endsWith(".class") || 
            lowerFileName.endsWith(".jar") || 
            lowerFileName.endsWith(".war") ||
            lowerFileName.contains("target/") ||
            lowerFileName.contains("build/")) {
            return false;
        }
        
        return true;
    }
}
